#pragma once

#include <iostream>
#include <string>
#include <functional>
#include <thread>

#include <windows.h>





class WinApi__Encoding__class
{

	//https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte
	//https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar
	//https://learn.microsoft.com/en-us/windows/win32/Intl/code-page-identifiers

public:


	WinApi__Encoding__class()
	{
		My_Quasi_Unicode_Сonsole_.set__pointer(this);
	}


	enum class result_flag
	{
		OK = 1,
		winapi_error = 2,
		bad_alloc = 3,
	};



public:


	const result_flag from_UTF16wstring_to_UTF8(const wchar_t* wchar_utf16_p, const size_t wchar_utf16_size, std::string& string_UTF8)
	{

		const size_t size_before = string_UTF8.size();


		//---------------------------------------------------------Предварительный расчет необходимой длинны под результативный буффер:--------------------------------------------------------------------
		
		const int size_final_byte = WideCharToMultiByte(CP_UTF8, 0, wchar_utf16_p, wchar_utf16_size, &string_UTF8[0], 0, NULL, NULL);  //5ым параметром я должен указать размер буффера под итоговое преобразование из UTF-16 в указанную кодировку в данном примере UTF-8, НО так как я не знаю какой размер будет занимать преобразованные символы, ТО, если вызвать функцию с 0-вым 6-ым парметром, то функция вернет это кол-во байт для финального буффера без завершающего нуля.

		if (size_final_byte == 0)  //Если возвращенное значение равно 0, значит функция не смогла подсчитать итоговое кол-во и значит это ошибка.
		{
			error = "WideCharToMultiByte: " + get__ErrorText(GetLastError());

			return result_flag::winapi_error;
		}

		//size_final_byte - теперь здесь итоговое кол-во байт, которое требуется для итогового буффера string_UTF8, чтобы туда преобразовать UTF-16 в UTF-8.
		
		//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



		try { string_UTF8.resize(size_before + size_final_byte); } catch (const std::bad_alloc& e) { error = e.what(); return  result_flag::bad_alloc; }



		//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		
		const int status = WideCharToMultiByte(CP_UTF8, 0, wchar_utf16_p, wchar_utf16_size, &string_UTF8[size_before], size_final_byte, NULL, NULL);  //Вызовем функцию WideCharToMultiByte - еще раз, но уже с size_final_byte:


		if (status == 0) //Если возвращенное значение равно 0, значит функция завершилась с ошибкой
		{
			error = "WideCharToMultiByte: " + get__ErrorText(GetLastError());

			string_UTF8.resize(size_before);

			return result_flag::winapi_error;
		}

		//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


		return result_flag::OK;
		
	}

	const result_flag from_UTF8_to_UTF16wstring(const char* char_UTF8_p, const size_t UTF8_size, std::wstring& wstring_utf16)
	{

		const size_t size_before = wstring_utf16.size();


		//---------------------------------------------------------Предварительный расчет необходимой длинны под результативный буффер:--------------------------------------------------------------------

		const int size_final_byte = MultiByteToWideChar(CP_UTF8, 0, char_UTF8_p, UTF8_size, &wstring_utf16[0], 0);  //5ым параметром я должен указать размер буффера в Символах wchar_t - под итоговое преобразование из UTF-8 в UTF-16, НО так как я не знаю какой размер будет занимать преобразованные символы, ТО, если вызвать функцию с 0-вым 6-ым парметром, то функция вернет кол-во Символов wchar_t требуемого для финального буффера.

		if (size_final_byte == 0)  //Если возвращенное значение равно 0, значит функция не смогла подсчитать итоговое кол-во и значит это ошибка.
		{
			error = "MultiByteToWideChar: " + get__ErrorText(GetLastError());

			return result_flag::winapi_error;
		}

		//size_final_byte - теперь здесь итоговое кол-во символов wchar_t, которое требуется для итогового буффера wstring_utf16, чтобы туда преобразовать UTF-8 в UTF-16.

		//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



		try { wstring_utf16.resize(size_before + size_final_byte); } catch (const std::bad_alloc& e) { error = e.what(); return  result_flag::bad_alloc; }



		//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		
		const int status = MultiByteToWideChar(CP_UTF8, 0, char_UTF8_p, UTF8_size, &wstring_utf16[size_before], size_final_byte);  //Вызовем функцию WideCharToMultiByte - еще раз, но уже с size_final_byte:


		if (status == 0) //Если возвращенное значение равно 0, значит функция завершилась с ошибкой
		{
			error = "MultiByteToWideChar: " + get__ErrorText(GetLastError());

			return result_flag::winapi_error;
		}

		//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


		return result_flag::OK;

	}

	const result_flag from_CP_ACP_to_UTF16wstring(const char* char_CP_ACP_p, const size_t CP_ACP_size, std::wstring& wstring_utf16)
	{


		const size_t size_before = wstring_utf16.size();


		//---------------------------------------------------------Предварительный расчет необходимой длинны под результативный буффер:--------------------------------------------------------------------

		const int size_final_byte = MultiByteToWideChar(CP_ACP, 0, char_CP_ACP_p, CP_ACP_size, &wstring_utf16[0], 0);  //5ым параметром я должен указать размер буффера в Символах wchar_t - под итоговое преобразование из CP_ACP в UTF-16, НО так как я не знаю какой размер будет занимать преобразованные символы, ТО, если вызвать функцию с 0-вым 6-ым парметром, то функция вернет кол-во Символов wchar_t требуемого для финального буффера.

		if (size_final_byte == 0)  //Если возвращенное значение равно 0, значит функция не смогла подсчитать итоговое кол-во и значит это ошибка.
		{
			error = "MultiByteToWideChar: " + get__ErrorText(GetLastError());

			return result_flag::winapi_error;
		}

		//size_final_byte - теперь здесь итоговое кол-во символов wchar_t, которое требуется для итогового буффера wstring, чтобы туда преобразовать CP_ACP в UTF-16.

		//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




		try { wstring_utf16.resize(size_before + size_final_byte); } catch (const std::bad_alloc& e) { error = e.what(); return  result_flag::bad_alloc; }



		//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

		const int status = MultiByteToWideChar(CP_ACP, 0, char_CP_ACP_p, CP_ACP_size, &wstring_utf16[size_before], size_final_byte);  //Вызовем функцию WideCharToMultiByte - еще раз, но уже с size_final_byte:


		if (status == 0) //Если возвращенное значение равно 0, значит функция завершилась с ошибкой
		{
			error = "MultiByteToWideChar: " + get__ErrorText(GetLastError());

			return result_flag::winapi_error;
		}

		//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


		return result_flag::OK;


	}

	const result_flag from_CP_ACP_to_UTF8(const char* char_CP_ACP_p, const size_t CP_ACP_size, std::string& string_UTF8)
	{

		//Так как функции MultiByteToWideChar и WideCharToMultiByte - преобразовывают между основной кодировкой UTF16 в дургие и из других в UTF16, то нет прямой функции, которая бы преобрзовала из CP_ACP однобайтовоq нацональной кодиовки в UTF8.
		//ПОЭТОМУ сначала преобразуем из CP_ACP в UTF16, а потом уже из UTF16 в UTF8.



		//---------------------------------------------------------------Преобразуем из CP_ACP в UTF16:Начало--------------------------------------------------
		std::wstring wstring_utf16_temp;

		result_flag result_ = from_CP_ACP_to_UTF16wstring(char_CP_ACP_p, CP_ACP_size, wstring_utf16_temp);

		if (result_ != result_flag::OK)
		{
			error = "from_CP_ACP_to_UTF16wstring: " + error;

			return result_;
		}

		//wstring_utf16_temp - теперт тут строка в кодировке UTF16
		//---------------------------------------------------------------Преобразуем из UTF8 в UTF16:Конец--------------------------------------------------




		//-----------------------------------------------------------------Преобразуем из UTF16 в UTF8:Начало--------------------------------------------------------------------

		result_ = from_UTF16wstring_to_UTF8(wstring_utf16_temp.c_str(), wstring_utf16_temp.size(), string_UTF8);


		if (result_ != result_flag::winapi_error)
		{
			error = "from_UTF16wstring_to_CP_ACP: " + error;

			return result_;
		}

		//-----------------------------------------------------------------Преобразуем из UTF16 в UTF8:Конец--------------------------------------------------------------------


		return result_flag::OK;


	}





	const std::string& get__ErrorName()
	{
		return error;
	}


private:

	std::string error;


	//*****************************************************************************************************************************************************************************************

	const std::string get__ErrorText(const HRESULT HRESULT_)
	{
		//HRESULT_ - за место HRESULT может быть код ошибки от GetLastError().

		std::string NameError; NameError.resize(1000);  //Выделим с запасом

		DWORD size = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, HRESULT_, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), &NameError[0], NameError.size(), nullptr);  //Получаем текстовый идентификатор ошибки ТОЛЬКО на Английском языке, чтобы не парится с кодировками и прочей фигней.

		NameError.resize(size);  //Сократи до фактического размера.

		return NameError;
	}


	//#################################################################################################
	public:

	class My_Quasi_Unicode_Сonsole
	{

		//ОСТОРЖНО ДАННЫЙ КОД МОЖЕТ ВЫЗВАТЬ КРОВОПОТЕКИ ИЗ ГЛАЗ.




	public:



		void set__pointer(WinApi__Encoding__class* WinApi__Encoding__class_p_)
		{
			WinApi__Encoding__class_p = WinApi__Encoding__class_p_;
		}


		void create_Window()
		{
			std::thread my_thread(&My_Quasi_Unicode_Сonsole::My_create_window, this);

			my_thread.detach();

			Sleep(1500);
		}


		void cout(const std::wstring& wstring)
		{

			//-----------------------------------------------------------
			wstring_text.append(wstring);

			SetWindowTextW(entry_field_1, wstring_text.c_str());
			//-----------------------------------------------------------

		}

		void cout(const std::string& string)
		{

			//Так как это строка в кодировке UTF8, а SetWindowTextW выводит в окно только в кодировке UTF16, то придется предварительно преобразовать в UTF16.

			//------------------------------------------------------------------

			WinApi__Encoding__class_p->from_UTF8_to_UTF16wstring(string.c_str(), string.size(), wstring_text);

			//------------------------------------------------------------------


			//-----------------------------------------------------------
			SetWindowTextW(entry_field_1, wstring_text.c_str());
			//-----------------------------------------------------------

		}


		void endl()
		{
			wstring_text.append(L"\r\n");

			SetWindowTextW(entry_field_1, wstring_text.c_str());
		}


		void free()
		{
			wstring_text.resize(0);

			SetWindowTextW(entry_field_1, wstring_text.c_str());
		}
		void shrink_to_fit__free()
		{
			wstring_text.resize(0);
			wstring_text.shrink_to_fit();

			SetWindowTextW(entry_field_1, wstring_text.c_str());
		}


	private:


		//--------------------------------------------------------
		std::wstring wstring_text;

		HWND hWnd;
		HWND entry_field_1;

		RECT my_rectos_main_windows;
		RECT my_rectos_edit_windows;

		SIZE textSize;
		//--------------------------------------------------------
		WinApi__Encoding__class* WinApi__Encoding__class_p;
		//--------------------------------------------------------


		static LRESULT CALLBACK WndProc1(HWND   hWnd, UINT   message, WPARAM wParam, LPARAM lParam)
		{


			//---------------------------------------------------------------------------------
			if (message == WM_NCCREATE)
			{
				My_Quasi_Unicode_Сonsole* pThis = static_cast<My_Quasi_Unicode_Сonsole*>(reinterpret_cast<LPCREATESTRUCT>(lParam)->lpCreateParams);

				SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pThis));
			}

			My_Quasi_Unicode_Сonsole* pThis = reinterpret_cast<My_Quasi_Unicode_Сonsole*>(GetWindowLongPtr(hWnd, GWLP_USERDATA));
			//---------------------------------------------------------------------------------




			//------------------------------------------------------------------------------------------
			PAINTSTRUCT ps;
			HDC hdc = 0;

			if (message == WM_PAINT)
			{
				hdc = BeginPaint(hWnd, &ps);  //Обработку сообщения WM_PAINT рекомендуется всегда начинать с вызова функции BeginPaint. Функция BeginPaint подготавливает указанное окно для рисования и заполняет структуру PAINTSTRUCT информацией о рисовании. Приложение не должно вызывать BeginPaint, кроме как в ответ на сообщение WM_PAINT . Каждый вызов BeginPaint должен иметь соответствующий вызов функции EndPaint : hWnd - дескриптор окна возвращенный функцией CreateWindow. ps - адрес структуры ps типа PAINTSTRUCT. Поляэтой структуры, заполняемые в результате выполнения функции BeginPaint, в дальнейшем используются операционной системой. Возвращаемое функцией значение — это дескриптор так называемого контекста устройства.Контекст устройства (device context) описывает физическое устройство вывода информации, например дисплей или принтер.Этот важнейший объект графической подсистемы Windows рассматривается подробно во второй главе.Сейчас достаточно понимания того, что контекст устройства — это некоторая внутренняя структура данных, сохраняющая часто используемые графические атрибуты, такие как цвет фона, перо, кисть, шрифт и им подобные параметры.Эти атрибуты используются при вызове всех рисующих функций, получающих дескриптор тип hDC в качестве параметра. Что все это значит не совсем понятно, но пока как то так.

				EndPaint(hWnd, &ps); //Функция EndPaint отмечает конец рисования в указанном окне. Эта функция требуется для каждого вызова функции BeginPaint , но только после завершения рисования.
			}
			//------------------------------------------------------------------------------------------






			//-------------------------------------------------------размера окна:Начало--------------------------------------

			if (message == WM_SIZE)      //Если кто то начинает изменять размер окна, то в оконную процедуру приходит сообщение WM_SIZE, отлавилваем его и:
			{
				//Теперь скорректируем размер дочерненого окна "entry_field_1" правильно под размер основного окна: минус ширины полосы прокрутки и минус дополнительно высотка заголовка окна.

				GetWindowRect(hWnd, &(pThis->my_rectos_main_windows));                 //Функция GetWindowRect заполняет структуру RECT данные о размере окна по хендлу hWnd.

				SetWindowPos(pThis->entry_field_1, NULL, 0, 0, pThis->my_rectos_main_windows.right - pThis->my_rectos_main_windows.left - GetSystemMetrics(SM_CYHSCROLL), pThis->my_rectos_main_windows.bottom - pThis->my_rectos_main_windows.top - GetSystemMetrics(SM_CYCAPTION) - GetSystemMetrics(SM_CXVSCROLL), SWP_NOMOVE | SWP_NOZORDER);
			}

			//-------------------------------------------------------размера окна:Начало--------------------------------------







			////////////////////////////////////////////Закраска текста в окне Edit_1 цветом:Начало////////////////////////////////////////////////////////
			//Вообще я не полностью понял, как это работает, но это работает:
			if (message == WM_CTLCOLOREDIT)                 //Вообщем это сообщение приходит каждый раз в Родительское окно, как я понял, когда должно быть перерисовано окно типа Edit.
			{
				if ((HWND)lParam == GetDlgItem(hWnd, 100))                    //Если message == WM_CTLCOLOREDIT, то в laparam в данный момент - это hwnd того окна Edit, которое нужно перерисовать, так как нам нужно перерисовать, только одно оконо, то отфильтруем его улсовием.
				{
					//SetTextColor((HDC)wParam, RGB(255, 0, 0));                  //Собсвенно устанавливает сам цвет текста.
					//return (LRESULT)GetSysColorBrush(COLOR_WINDOW);             //Хуй знает, че делает, но без этого не работает.
				}

			}
			////////////////////////////////////////////Закраска текста в окне Edit_1 цветом:Начало////////////////////////////////////////////////////////







			if (message == WM_CLOSE)  //Когда пользователь закрывает окно, к примеру нажимает курсором крестик, то Windows генерирует сообщение WM_CLOSE и направляет его напрямую в кокнную процедуру миная очередь сообщений(в этом можно убедится, так как функцией GetMessage его не отловить). Поэтому отлавилвает это сообщение в оконной процедуре окна.
			{
				DestroyWindow(hWnd);   //Отловив сообщение теперь нужно вызвать функцию DestroyWindow, которое разрушит окно генерируя сообщение WM_DESTROY и это сообщение также напрямую миную очередь сообщений напарвляется напрямую в оконную процедуру:  Уничтожает указанное окно. Функция отправляет сообщения WM_DESTROY и WM_NCDESTROY в окно, чтобы деактивировать его и удалить с него фокус клавиатуры. Функция также разрушает меню окна, очищает очередь сообщений потока, уничтожает таймеры, удаляет владельца буфера обмена и разрывает цепочку просмотра буфера обмена (если окно находится в верхней части цепочки просмотра). Если указанное окно является родительским или оконным владельцем, DestroyWindow автоматически уничтожает связанный дочерний или принадлежащие ему окна, когда оно уничтожает родительское или оконное окно владельца.Функция сначала уничтожает дочерние или собственные окна, а затем разрушает родительское или владелецское окно. DestroyWindow также уничтожает немодальные диалоговые окна, созданные функцией CreateDialog .
			}

			if (message == WM_DESTROY)  //Соотвесвенно отлавливаем сообщение WM_DESTROY и вызываем функцию PostQuitMessage, которая генерирует сообщение WM_QUIT, которое уже отсылается в общуюю очередь, GetMessage ее отлавливает и незамедлительно выходит из цикла.
			{
				PostQuitMessage(0);
			}


			return DefWindowProc(hWnd, message, wParam, lParam); //Стандартная функция обработки сообщений окна: Обычно программисты используют оператор switch для определения того, какое сообщение получено и как его обрабатывать.Если сообщение обрабатывается, то оконная процедура обязана вернуть нулевое значение.Все сообщения, необрабатываемые оконной процедурой, должны передаваться системной функцииDefWindowProc.В этом случае оконная процедура должна вернуть то значение,которое возвращает DefWindowProc.


		}
	

		const std::string My_create_window()
		{
			//Вообще, по крайней мере для создания простого окна сама функция WinMain c этими 4мя параметрами - по факту может быть и не нужна(при условии что есть точка входа int main(), если ее нет, то нужна точка входа WinMain со всеми 4 параметрами, без них работать не будет). Так как по факту для создания окна нужен парметр HINSTANCE hInstance - это некий Дескриптор текущего экземпляра приложения, ну так вот его можно получить не только из WinMain`а, но и с помощью функции GetModuleHandleA:Если этот параметр имеет значение NULL, GetModuleHandle возвращает дескриптор файла, используемого для создания вызывающего процесса (файл .exe).

			HINSTANCE hInstance = GetModuleHandleA(NULL); // За место первого параметра WinMain - hInstance.  Вообщем hInstance - это что то типа дескриптора приложения или дескриптора процесса или потока в котором создается Окно.

			if (hInstance == NULL)
			{
				return "GetModuleHandleA == NULL:" + std::to_string(GetLastError());
			}

			///////////////////////////////////////////////////////
			WNDCLASSEX My_WNDCLASSEX;       //Структура WNDCLASSEX - параметры которой описывают параметры того, как будет выглядеть само создаваеое окно.

			wchar_t My_lpszClassName[] = L"My_Clas_Windows";

			My_WNDCLASSEX.cbSize = sizeof(WNDCLASSEX);       //Собсвенное sizeof самой структуры
			My_WNDCLASSEX.style = CS_HREDRAW | CS_VREDRAW;   // CS_HREDRAW | CS_VREDRAW; - вообщем это видимо наболее часто используемые стили и под стилями тут понимается не вид окна, как оно выглядет, а вот это: CS_VREDRA-Внутренняя область окна должна быть перерисована при изменении высоты окна. CS_HREDRAW	Внутренняя область окна должна быть перерисована при изменении ширины окна. Если для класса заданы стили CS_HREDRAW и CS_VREDRAW, при изменении размеров окна функция окна может получить сообщение WM_PAINT. В этом случае функция окна должна перерисовать часть окна или все окно. Разумеется, если вы просто уменьшили размер окна, перерисовывать ничего не надо, и функция окна в этом случае не получит сообщения WM_PAINT. Пока что не совсем понимаю, что все это значит.
			My_WNDCLASSEX.lpfnWndProc = WndProc1;             //Короче это указатель на функцию сигнатуры WindowProc оконной процедуры, именно той которая будет обрбатывать сообьщения от Windows приходящие в это созданное окно.
			My_WNDCLASSEX.cbClsExtra = 0;                    //Какое то дополнителоьное кол-во байт... вообщем везде пишут, что в большинстве случаев - это значение 0.
			My_WNDCLASSEX.cbWndExtra = 0;                    //Какое то дополнителоьное кол-во байт... вообщем везде пишут, что в большинстве случаев - это значение 0.
			My_WNDCLASSEX.hInstance = hInstance;             //Вообщем это дескриптор текущего экземпляра приложения. Чтобы это значило ? Вообщем это дескриптор, который как бы заполняет функция WinMain.  Вообщем hInstance - это что то типа дескриптора приложения или дескриптора процесса или потока в котором создается Окно.
			My_WNDCLASSEX.hIcon = LoadIcon(hInstance, IDI_APPLICATION);   // Это какая будет иконка у окна, та что слева в верхнем углу отображается. В данном случае это стандартная "безымянная" иконка. Пока что мне не какие другие иконки не нужны.
			My_WNDCLASSEX.hCursor = LoadCursor(NULL, IDC_ARROW);          // Ну это соответсвенно вид самого курсора, которые будет отображатся, когда курсор будет проходить на фоне созданного окна.
			My_WNDCLASSEX.hbrBackground = (HBRUSH)(COLOR_WINDOW + 0);     //Этот параметр отвечает за цвет всей внутренней части окна. На сайте макрософт так и написано, что: Значение цвета должно быть одним из следующих стандартных системных цветов (значение 1 должно быть добавлено к выбранному цвету). Если задано значение цвета, вы должны привести этот тип к HBRUSH: все типы (видимо стандартнрые) смотреть на сайте: https://docs.microsoft.com/ru-ru/windows/win32/api/winuser/ns-winuser-wndclassexw
			My_WNDCLASSEX.lpszMenuName = NULL;                        //Вообщем штука, которая ответчает каким то оброазом за меню окна. Каким образом пока не разбирался.
			My_WNDCLASSEX.lpszClassName = L"My_Clas_Windows";                     //szWindowClass;  //Вообщем это какое то название класса этого окна. Это типа для идентификации окна служит это значение, чтобы типа винда различала различные окна по этим идентификаторам. Соотвесвенно, этот параметр уникальный и не должен совпадать с параметрами других созданных окон.
			My_WNDCLASSEX.hIconSm = LoadIcon(My_WNDCLASSEX.hInstance, IDI_APPLICATION);  // Это какая будет иконка у окна, та что слева в верхнем углу отображается. В данном случае это стандартная "безымянная" иконка. Пока что мне не какие другие иконки не нужны.
			///////////////////////////////////////////////////////



			int result_RegisterClassEx = RegisterClassEx(&My_WNDCLASSEX);  //Регистрирует класс окна для последующего использования в вызовах функции CreateWindow или CreateWindowEx. Входной параметр это адрес структуры WNDCLASSEX. Если функция завершается ошибкой, то функция возвращает 0, код ошибки смотреть через GetLastError();



			/////////////////////////////////////////////////////
			if (result_RegisterClassEx == 0)  //Если функция result_RegisterClassEx возвратила 0, значит ошибка:
			{
				return "Error: RegisterClassEx == 0:" + std::to_string(GetLastError());
			}
			/////////////////////////////////////////////////////



			/////////////////////////////////////////////////////
			 //Функция создания окна
			hWnd = CreateWindow(
				My_WNDCLASSEX.lpszClassName,                     //Вообщем это названия класса окна, которое соотвесвует ранее заполненому уже параметру lpszClassName из структуры WNDCLASSEX
				L"My_Quasi_Unicode_Сonsole东",                    //Название заголовока окна
				WS_OVERLAPPEDWINDOW,                             //Стиль окна, как к примеру: WS_MAXIMIZE - Окно изначально развернуто; WS_HSCROLL - Окно имеет горизонтальную полосу прокрутки...итд полный список смотреть на:https://docs.microsoft.com/ru-ru/windows/win32/winmsg/window-styles  / Тут же используем стандартно применяющийся в большинстве случаев: WS_OVERLAPPEDWINDOW - Окно является перекрывающимся окном.
				255,                                             //Начальная позиция окна по оси Х, в экранно-пиксельных координатах. У окна есть один нюанс: слева справа и снизу у окна есть область для тени(занимает 7 пикселей), в Windows10 это теневая область не отображается, но она сущесвует (в других Винусах она вроде бы отображается, как теневая область для красоты) - ну так вот, в Windows10 эта область не отображается и если создать окно с кординатой Х=0, то есть соотвесвующее положению в самом левой углу рабочего стола, то визуально границы окна не дойдут на 7 пикселей до границы, хотя на самом деле есетсвенно шибки нет, просто границы окна не видимы.
				0,                                             //Начальная позиция окна по оси Y, в экранно-пиксельных координатах.
				1000,                                             //Ширина окна в пикселях. Ширина окна в единицах устройства. //Для перекрывающихся окон nWidth - это либо ширина окна в координатах экрана, либо CW_USEDEFAULT . Если nWidth - CW_USEDEFAULT , система выбирает ширину и высоту по умолчанию для окна; ширина по умолчанию простирается от начальной x-координаты до правого края экрана, а высота по умолчанию простирается от начальной y-координаты до верхней части области значка. CW_USEDEFAULT действителен только для перекрывающихся окон; если CW_USEDEFAULT указан для всплывающего или дочернего окна, nWidth и nHeight устанавливаются в ноль.
				500,                                             //Высота окна в пикселях. Высота окна устройства в единицах измерения. //Для перекрывающихся окон nHeight - высота окна в экранных координатах. Если nWidth установлено в CW_USEDEFAULT , система игнорирует nHeight .
				NULL,                                            //Вообщем, как я понял это дескриптор родительского окна в случае, если я создаю дочернее окно. Так как в данном случае я не создаю дочернее окно, то NULL. //Дескриптор родительского окна или окна владельца создаваемого окна. Чтобы создать дочернее окно или собственное окно, укажите действительный дескриптор окна. Этот параметр не является обязательным для всплывающих окон.Чтобы создать окно только для сообщений, укажите HWND_MESSAGE или дескриптор для существующего окна только для сообщений.
				NULL,                                            //Вообщем это некий дескриптор меню или дочернего окна, пока у меня его нет, так что NULL. //Дескриптор меню или указывает идентификатор дочернего окна в зависимости от стиля окна. Для перекрывающегося или всплывающего окна hMenu определяет меню, которое будет использоваться с окном; это может быть ПУСТО (NULL), если будет использоваться меню класса. Для дочернего окна hMenu указывает идентификатор дочернего окна, целочисленное значение, используемое элементом управления диалогового окна для уведомления его родителя о событиях. Приложение определяет идентификатор дочернего окна; оно должно быть уникальным для всех дочерних окон с одним и тем же родительским окном.
				My_WNDCLASSEX.hInstance,                         //Дескриптор экземпляра модуля, который будет связан с окном. То есть это первый параметр в WinMain, который WinMain, как бы возвращает заполняет. Который мы уже заполняли в структуре WNDCLASSEX.
				this                                             //Вообщем тут NULL. //Указатель на значение , которое будет передан в окно через CREATESTRUCT структуры ( lpCreateParams члена) , на который указывает LPARAM парам в WM_CREATE сообщении. Это сообщение отправляется в созданное окно этой функцией до его возврата.Если приложение вызывает CreateWindow для создания окна клиента MDI, lpParam должен указывать на структуру CLIENTCREATESTRUCT.Если клиентское окно MDI вызывает CreateWindow для создания дочернего окна MDI, lpParam должен указывать на структуру MDICREATESTRUCT.lpParam может быть NULL, если никакие дополнительные данные не нужны.
			);
			/////////////////////////////////////////////////////

			if (hWnd == INVALID_HANDLE_VALUE) //Если функция CreateWindow ничего не вернула
			{
				//MessageBox(NULL, L"Error: CreateWindow == INVALID_HANDLE_VALUE", TEXT("Warning"), MB_OK | MB_ICONASTERISK);
				return "Error: CreateWindow == INVALID_HANDLE_VALUE:" + std::to_string(GetLastError());
			}




			///////////////////////----------------------------------///////////////////////////////////////
			
			//Создадим поле ввода-1// ТЕКСТ БУДЕМ ВЫВОДИТЬ СЮДА - ЧТОБЫ ИМЕТЬ ВОЗОЖНОСТЬ НЕ МУЧИТСЯ ИСАМОМУ НЕ РЕАЛИЗОВЫВАТЬ ГОРИЗОАНТЛЬНУЮ И ВЕРТИКАЛЬНУЮ ПРОКРУТКУ В ОСНОВНОМ ОКНЕ.

			entry_field_1 = CreateWindowW(
				L"edit",                                                  //Вообщем это названия класса окна. В данном случае, в случае создания Кнопки - название класса имееет строгое название - это "edit" иначе поле ввод не создатся.
				L"",                                                      //Название заголовока окна
				WS_VISIBLE | WS_CHILD | WS_BORDER | ES_MULTILINE | WS_VSCROLL | WS_HSCROLL | ES_READONLY,       //Стиль окна, в данном случае WS_VISIBLE говорит функции, что окно должно быть изначально видно(если его не указать кнопка будет невидимой или вообще ее не будет), WS_CHILD - говорит о том, что окно является дочерним окном. WS_BORDER - говорит о том, что поле ввода будет окружено рамкой (ну типа красиво и очерчивает границы ввода). ES_AUTOHSCROLL - говорит о том, что поле ввода не будет иметь лимита по вводу символов, то есть если этот флаг не указать, то кол-во символов которые я смогу внести будет ровно по длинне самого поля ввода, то есть символы не будет сдвигатся при вводе юольше, чем длинна самого поля ввода.
				0,                                                      //Начальная позиция окна по оси Х, в экранно-пиксельных координатах. У окна есть один нюанс: слева справа и снизу у окна есть область для тени(занимает 7 пикселей), в Windows10 это теневая область не отображается, но она сущесвует (в других Винусах она вроде бы отображается, как теневая область для красоты) - ну так вот, в Windows10 эта область не отображается и если создать окно с кординатой Х=0, то есть соотвесвующее положению в самом левой углу рабочего стола, то визуально границы окна не дойдут на 7 пикселей до границы, хотя на самом деле есетсвенно шибки нет, просто границы окна не видимы.
				0,                                                       //Начальная позиция окна по оси Y, в экранно-пиксельных координатах.
				1000,                                                      //Ширина окна в пикселях. Ширина окна в единицах устройства. //Для перекрывающихся окон nWidth - это либо ширина окна в координатах экрана, либо CW_USEDEFAULT . Если nWidth - CW_USEDEFAULT , система выбирает ширину и высоту по умолчанию для окна; ширина по умолчанию простирается от начальной x-координаты до правого края экрана, а высота по умолчанию простирается от начальной y-координаты до верхней части области значка. CW_USEDEFAULT действителен только для перекрывающихся окон; если CW_USEDEFAULT указан для всплывающего или дочернего окна, nWidth и nHeight устанавливаются в ноль.
				500,                                                       //Высота окна в пикселях. Высота окна устройства в единицах измерения. //Для перекрывающихся окон nHeight - высота окна в экранных координатах. Если nWidth установлено в CW_USEDEFAULT , система игнорирует nHeight .
				hWnd,                                                     //Вообщем, как я понял это дескриптор родительского окна в случае, если я создаю дочернее окно. Так как в данном случае я не создаю дочернее окно, то NULL. //Дескриптор родительского окна или окна владельца создаваемого окна. Чтобы создать дочернее окно или собственное окно, укажите действительный дескриптор окна. Этот параметр не является обязательным для всплывающих окон.Чтобы создать окно только для сообщений, укажите HWND_MESSAGE или дескриптор для существующего окна только для сообщений.
				(HMENU)100,                                               //Вообщем это некий дескриптор меню или дочернего окна, пока у меня его нет, так что NULL. //Дескриптор меню или указывает идентификатор дочернего окна в зависимости от стиля окна. Для перекрывающегося или всплывающего окна hMenu определяет меню, которое будет использоваться с окном; это может быть ПУСТО (NULL), если будет использоваться меню класса. Для дочернего окна hMenu указывает идентификатор дочернего окна, целочисленное значение, используемое элементом управления диалогового окна для уведомления его родителя о событиях. Приложение определяет идентификатор дочернего окна; оно должно быть уникальным для всех дочерних окон с одним и тем же родительским окном.
				NULL,                                                     //Дескриптор экземпляра модуля, который будет связан с окном. То есть это первый параметр в WinMain, который WinMain, как бы возвращает заполняет. Который мы уже заполняли в структуре WNDCLASSEX.
				NULL                                                      //Вообщем тут NULL. //Указатель на значение , которое будет передан в окно через CREATESTRUCT структуры ( lpCreateParams члена) , на который указывает LPARAM парам в WM_CREATE сообщении. Это сообщение отправляется в созданное окно этой функцией до его возврата.Если приложение вызывает CreateWindow для создания окна клиента MDI, lpParam должен указывать на структуру CLIENTCREATESTRUCT.Если клиентское окно MDI вызывает CreateWindow для создания дочернего окна MDI, lpParam должен указывать на структуру MDICREATESTRUCT.lpParam может быть NULL, если никакие дополнительные данные не нужны.
			);
			/////////////////////////////////////////////////////

			if (entry_field_1 == INVALID_HANDLE_VALUE) //Если функция CreateWindow ничего не вернула
			{
				//MessageBox(NULL, L"Error: CreateWindow == INVALID_HANDLE_VALUE", TEXT("Warning"), MB_OK | MB_ICONASTERISK);
				return "Error: CreateWindow == INVALID_HANDLE_VALUE:" + std::to_string(GetLastError());
			}





			//------------------------------------------------------------------------------------------------------------------------------
			//Создадим и назначми щрифт окну edit:
			//Описаение этого блока - в winmain:

			LOGFONT my_LOGFONT_struct;
			memset(&my_LOGFONT_struct, 0, sizeof(LOGFONT));
			memcpy(my_LOGFONT_struct.lfFaceName, L"Calibri", sizeof(L"Calibri"));    //Тип шрифта
			my_LOGFONT_struct.lfHeight = 18;                                    // Размер шрифта
			HFONT hFont = CreateFontIndirectW(&my_LOGFONT_struct);

			if (hFont == NULL)
			{
				std::cout << "CreateFontIndirectW()_Error" << std::endl;
				DestroyWindow(hWnd);                //Закрываем окно
				PostQuitMessage(0);                 //Закрываем окно
			}


			SendMessage(GetDlgItem(hWnd, 100), WM_SETFONT, (WPARAM)(hFont), MAKEWORD(1, 0));  //Есть Нюанс читать до окнца. И собстно посылаем сообщеие в окно в котром хотим изменить шрифт у текста, в данном случае это окно-поле edit. WM_SETFONT - как раз говорит окну установить шрифт. 3ий параметр - сам созданный обьект шрифта.  и 4 -параметр!!!НЮАНС: если в 4ом параметре установить просто 0, то, если мы шрифт применяем еще до создания самого окна, то в этом случае проблемы не будет, после создания окна шрифт сразу применится к тексту окна, НО, если мы посылаем сообщение об изменнии шрифта в окно уже после создания окна, ну к примеру по нажатию кнопуи изменяем шрифт в какой нибудь дочернем окне(пример смотреть в winproc), то шрифт к тексту применятся не сразу, а к примеру только после того, как я мышкой нажму по этому окно, ну то есть так не годится и ВОТ для этого, чтобы шрифт применялся сразу нужно в 4-ом параметре в младшем байте lparam установить 1, то есть MAKEPARAM(1,0) - пример этого, как я уже написал смотреть в Windproc в условии отслеживания нажатии кнопки.
			//-------------------------------------------------------------------------------------------------------------------------------------





		///////////////////////////////////
			ShowWindow(hWnd,                          //Соответсвенно это дескриптор возвращенный функцией CreateWindow
				SW_SHOWDEFAULT);  //nCmdShow             //Дескриптор nCmdShow из WinMain, тот что последний аргумент в WinMain(), отвечает за показ создаваемого окна, ну типа как оно появится на экране. Но, практически можно за место самого параметра nCmdShow можно указать флаг, того как оно это окно появится - там в полный размер экрана или стандартного какого то размера или вообще свернутое: SW_SHOWDEFAULT, SW_HIDE, SW_MAXIMIZE, SW_MINIMIZE ... все флаги смотреть в описании функции ShowWindow.
			UpdateWindow(hWnd);
			///////////////////////////////////


			////////////////////////////////////////
			MSG msg;
			while (GetMessage(&msg, NULL, 0, 0))  // Вообщем есть некая очередь сообщения Windows и в этой очереди сообщения от кликов мышки, клавы, джойстиков и прочее, но эта очередь сообщений от внешних устройств дсотупна только для моих созданных окон, то есть если в пределах моего созданного окна мыб произведен клик мыши, то сообщение об этом всталяется в очередь сообщений и как бы доступно мне, и вот с помощью функции GetMessage каждое сообщение как бы извлекается из очереди и данные этого извлеченного сообщнения записывает в переMessage структуру MSG и передается далее на обработку функции DispatchMessage. Функция GetMessage возвращает значение TRUE(или отличное от 0, только не знаю может быть ли отрицательное) при извлечении любого сообщения, кроме одного — WM_QUIT. Получив сообщение WM_QUIT, функция возвращает значение FALSE(или 0).В случае ошибки возвращается -1(ошибка проверяется GetLasterror()).  В результате этого происходит немедленный выход из цикла, и приложение завершает работу, возвращая операционной системе код возврата msg.wParam(то есть параметр wParam из структуры MSG). То есть цикл будет работать до тех пор пока GetMessage не получить в MSG в параметре UINT Message == WM_QUIT. Это может к примерк произойти, когда происходит клик мышки по крестику окна - то есть по закртиыю окна.
			{
				TranslateMessage(&msg);   //Вообщем говорят, что эта функция не обязательная, но везде ее все раво ее пишут, поэтому и тут пусь будет, но описываеть что она делает не буду.
				DispatchMessage(&msg);    //Вообщем эта функция отправляеет заполненную структуру MSG в функцию обратного вызова Windproc созданного окна.
			}
			////////////////////////////////////////


			return std::to_string((int)msg.wParam);

		}



		void calculate_TextSize()
		{
			//HDC hdc = GetDC(hwnd);
			//GetTextExtentPoint32(hdc, yourText.c_str(), yourText.length(), &textSize);
			//ReleaseDC(hwnd, hdc);
		}


	};

	My_Quasi_Unicode_Сonsole My_Quasi_Unicode_Сonsole_;
	//#################################################################################################

};
